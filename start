hello.py
动态路径
@login_required
修饰路径（设置访问权限）


page 88

@app.route('/user/<name>')
def user(name):
    return '<h1>Hello, %s!</h1>' % name
    """
    动态路径
    """
    <link rel=stylesheet type=text/css href="{{ url_for('static', filename='style.css') }}">
    <form action="{{ url_for('login') }}" method=post>
            return render_template('hello.html', name=name)
请求响应上下文
app_ctx = app.app_context()
app_ctx.push()
公网ip访问
app.run('0.0.0.0',80)
返回ua
user_agent = request.headers.get('User-Agent')
    return '<p>Your browser is %s</p>' % user_agent
    
render_template('home.html')
    
    
    
    
请求调度
from hello import app
>>> app.url_map
Map([<Rule '/' (HEAD, OPTIONS, GET) -> index>,
<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,
<Rule '/user/<name>' (HEAD, OPTIONS, GET) -> user>])
请求hook
request
响应
    
        return '<h1>Bad Request</h1>' ,400

设置重定向

公网访问
python hello.py runserver --host 0.0.0.0

模板
使用Jinja2
渲染模板
变量
每个元素

控制结构

错误处理
@app.errorhandler(404)
def page_not_found(e):
return render_template('404.html'), 404
@app.errorhandler(500)
def internal_server_error(e):
return render_template('500.html'), 500

app.config['SQLALCHEMY_DATABASE_URI'] = os.environ('DATABASE_URI')
0/?page=10?

# inside a flask view
def some_view():
    try:
        page = int(request.args.get('page', 1))
        assert page == 10
        参数
admin base view
选择器   选择地方语言


safe Renders the value without applying escaping
capitalize Converts the first character of the value to uppercase and the rest to lowercase
lower Converts the value to lowercase characters
upper Converts the value to uppercase characters
title Capitalizes each word in the value
trim Removes leading and trailing whitespace from the value
striptags Removes any HTML tags from the value before rendering


根据修饰器触发函数
app.run(host='0.0.0.0')
This tells your operating system to listen on all public IPs.
所有公共IP
例程
变量规则
@app.route('/user/<username>')
def show_user_profile(username):
    # show the user profile for that user
    return 'User %s' % username

@app.route('/post/<int:post_id>')
def show_post(post_id):
    # show the post with the given id, the id is an integer
    return 'Post %d' % post_id
    
    全局配置
    
    
类
>>> class Student(object):
...     name = 'Student'
...
>>> s = Student() # 创建实例s
>>> print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
>>> print(Student.name) # 打印类的name属性
Student
>>> s.name = 'Michael' # 给实例绑定name属性
>>> print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
>>> print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
>>> del s.name # 如果删除实例的name属性
>>> print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student

if __name__ == "__main__":
    # To allow aptana to receive errors, set use_debugger=False
    app = create_app(config="config.yaml")

    if app.debug: use_debugger = True
    try:
        # Disable Flask's debugger if external debugger is requested
        use_debugger = not(app.config.get('DEBUG_WITH_APTANA'))
    except:
        pass
    app.run(use_debugger=use_debugger, debug=app.debug,
            use_reloader=use_debugger, host='0.0.0.0')
创建url
>>> from flask import Flask, url_for
>>> app = Flask(__name__)
>>> @app.route('/')
... def index(): pass
...
>>> @app.route('/login')
... def login(): pass
...
>>> @app.route('/user/<username>')
... def profile(username): pass
...
>>> with app.test_request_context():
...  print url_for('index')
...  print url_for('login')
...  print url_for('login', next='/')
...  print url_for('profile', username='John Doe')
定义url方法
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        do_the_login()
    else:
        show_the_login_form()
渲染模板
from flask import render_template

@app.route('/hello/')
@app.route('/hello/<name>')
def hello(name=None):
    return render_template('hello.html', name=name)
    
    html的内容
    <!doctype html>
<title>Hello from Flask</title>
{% if name %}
  <h1>Hello {{ name }}!</h1>
{% else %}
  <h1>Hello World!</h1>
{% endif %}

sqlite3 xx.db < schema.sql

the client terminated the request early and the application was still reading from the incoming data.
the database server was overloaded and could not handle the query.
a filesystem is full
a harddrive crashed
a backend server overloaded
a programming error in a library you are using
network connection of the server to another system failed.
调试
if __name__ == "__main__":
    # To allow aptana to receive errors, set use_debugger=False
    app = create_app(config="config.yaml")

    if app.debug: use_debugger = True
    try:
        # Disable Flask's debugger if external debugger is requested
        use_debugger = not(app.config.get('DEBUG_WITH_APTANA'))
    except:
        pass
    app.run(use_debugger=use_debugger, debug=app.debug,
            use_reloader=use_debugger, host='0.0.0.0')
            
app.config is a dict containing configuration parameters
@app.route() is by default limited to GET requests. Allowed HTTP methods of an action can be specified using the methods keyword arg.
url_for(route_name, **kwargs) should be used to generate urls for your handlers. It takes as first parameter the function name and as keyword args any needed parameters to generate the url.
redirect(url) creates an HTTP response with a redirect code and location
abort(http_code) is used to create error responses and stop the executing function.

